let MemoryHelper = require( 'memory-helper' ),
    genish       = require( 'genish.js' ),
    createUgenTemplate = require( './ugenTemplate.js' )

let Gibberish = {
  dirtyUgens: [],
  callbackUgens: [],
  callbackNames: [],
  graphIsDirty: false,
  ugens: {},

  output: null,

  memory : null, // 20 minutes by default?
  factory: null, 
  genish,

  init( memAmount ) {
    let numBytes = memAmount === undefined ? 20 * 60 * 44100 : memAmount

    this.memory = MemoryHelper.create( numBytes )
    this.template = createUgenTemplate( this )
    this.factory  = this.template.factory

    this.genish.export( window )

    this.ugens.oscillators = require( './oscillators.js' )( this )
    this.ugens.binops      = require( './binops.js' )( this )
    this.ugens.bus         = require( './bus.js' )( this )
    this.ugens.bus2        = require( './bus2.js' )( this )

    this.ugens.oscillators.export( this )
    this.ugens.binops.export( this )
    this.Bus = this.ugens.bus
    this.Bus2 = this.ugens.bus2

    this.output = this.Bus2()
    this.createContext()
    this.createScriptProcessor()
  },

  dirty( ugen ) {
    this.dirtyUgens.push( ugen )
    this.graphIsDirty = true
  },

  clear() {
    this.output.inputs = [0]
    this.dirty( this.output )
  },

  createContext() {
    let AC = typeof AudioContext === 'undefined' ? webkitAudioContext : AudioContext
    this.ctx = new AC()
    gen.samplerate = this.ctx.sampleRate

    let start = () => {
      if( typeof AC !== 'undefined' ) {
        if( document && document.documentElement && 'ontouchstart' in document.documentElement ) {
          window.removeEventListener( 'touchstart', start )

          if( 'ontouchstart' in document.documentElement ){ // required to start audio under iOS 6
            let mySource = utilities.ctx.createBufferSource()
            mySource.connect( utilities.ctx.destination )
            mySource.noteOn( 0 )
          }
         }
      }
    }

    if( document && document.documentElement && 'ontouchstart' in document.documentElement ) {
      window.addEventListener( 'touchstart', start )
    }

    return this
  },

  createScriptProcessor() {
    this.node = this.ctx.createScriptProcessor( 1024, 0, 2 ),
    this.clearFunction = function() { return 0 },
    this.callback = this.clearFunction

    this.node.onaudioprocess = function( audioProcessingEvent ) {
      let gibberish = Gibberish,
          callback  = gibberish.callback,
          outputBuffer = audioProcessingEvent.outputBuffer

      let left = outputBuffer.getChannelData( 0 ),
          right= outputBuffer.getChannelData( 1 )

      for (let sample = 0; sample < left.length; sample++) {
        if( gibberish.graphIsDirty ) { callback = gibberish.generateCallback() }
        
        // XXX cant use destructuring, babel makes it something inefficient...

        let out = callback.apply( null, gibberish.callbackUgens )

        left[ sample  ] = out
        right[ sample ] = out
      }
    }

    this.node.connect( this.ctx.destination )

    return this
  }, 

  generateCallback() {
    let uid = 0,
        callbackBody, lastLine

    //for( let ugen of this.dirtyUgens ) {
    //  this.callbackNames.push( ugen.name )
    //  this.callbackUgens.push( ugen )
    //}

    callbackBody = this.processGraph( this.output )
    lastLine = callbackBody[ callbackBody.length - 1]
    
    callbackBody.push( '\n\treturn ' + lastLine.split('=')[0].split( ' ' )[1] )

    console.log( 'callback:\n', callbackBody.join('\n') )
    this.callback = Function( ...this.callbackNames, callbackBody.join( '\n' ) )
    this.callback.out = []

    return this.callback 
  },

  processGraph( output ) {
    this.callbackUgens.length = 0
    this.callbackNames.length = 0

    this.callbackUgens.push( output )

    let body = this.processUgen( output )
    this.callbackNames = this.callbackUgens.map( v => v.ugenName )

    //console.log( this.callbackNames )

    this.dirtyUgens.length = 0
    this.graphIsDirty = false

    return body
  },

  processUgen( ugen, block ) {
    if( block === undefined ) block = []

    let dirtyIdx = Gibberish.dirtyUgens.indexOf( ugen )
    
    if( ugen.block === undefined || dirtyIndex !== -1 ) {
  
      let line = `\tvar v_${ugen.id} = ` 
      
      if( !ugen.binop ) line += `${ugen.ugenName}( `

      let length = ugen.binop ? ugen.inputs.length : ugen.inputNames.length;
      
      for( let i = 0; i < length; i++  ) {
        // binop.inputs is actual values, not just property names
        let input = ugen.binop ? ugen.inputs[ i ] : ugen[ ugen.inputNames[ i ] ]

        if( typeof input === 'number' ) {
          line += input
        }else{
          if( input === undefined ) console.log( i, ugen )
          Gibberish.processUgen( input, block )

          if( !input.binop ) Gibberish.callbackUgens.push( input )

          line += `v_${input.id}`
        }

        if( i < length - 1 ) {
          line += ugen.binop ? ' ' + ugen.op + ' ' : ', ' 
        }
      }

      line += ugen.binop ? '' : ' )'

      block.push( line )
    }else if( ugen.block ) {
      return ugen.block
    }

    return block
  }
    
}

module.exports = Gibberish
