let g = require( 'genish.js' )

module.exports = function( Gibberish ) {

  let TemplateFactory = ( ugen, propertyList, _envCheck ) => {
    let Template = props => {
      let properties = Object.assign( {}, { isStereo:true }, props )

      let synth = properties.isStereo ? Gibberish.Bus2() : Gibberish.Bus(),
          voices = [],
          maxVoices = props.maxVoices || 16,
          voiceCount = 0

      for( let i = 0; i < maxVoices; i++ ) {
        voices[i] = ugen( properties )
        voices[i].callback.ugenName = voices[i].ugenName
        voices[i].isConnected = false
      }

      Object.assign( synth, {
        properties,
        voices,
        isStereo: properties.isStereo,
        triggerChord: null,
        lastNote: null,

        note( freq ) {
          let voice = this.__getVoice__()
          Object.assign( voice, synth.properties )
          voice.note( freq )
          this.__runVoice__( voice, this )
          this.triggerNote = freq
        },

        // XXX this is not particularly satisfying...
        trigger( gain ) {
          if( this.triggerChord !== null ) {
            this.triggerChord.forEach( v => {
              let voice = this.__getVoice__()
              Object.assign( voice, synth.properties )
              voice.note( v )
              voice.gain = gain
              this.__runVoice__( voice, this )
            })
          }else if( this.triggerNote !== null ) {
            let voice = this.__getVoice__()
            Object.assign( voice, synth.properties )
            voice.note( this.triggerNote )
            voice.gain = gain
            this.__runVoice__( voice, this )
          }else{
            let voice = this.__getVoice__()
            Object.assign( voice, synth.properties )
            voice.trigger( gain )
            this.__runVoice__( voice, this )
          }
        },

        __getVoice__() {
          return voices[ voiceCount++ % voices.length ]
        },

        __runVoice__( voice, poly ) {
          if( !voice.isConnected ) {
            voice.connect( poly, 1 )
            voice.isConnected = true
          }
          
          let envCheck
          if( _envCheck === undefined ) {
            envCheck = ()=> {
              if( voice.env.isComplete() ) {
                poly.disconnect( voice )
                voice.isConnected = false
              }else{
                Gibberish.blockCallbacks.push( envCheck )
              }
            }
          }else{
            envCheck = _envCheck( voice, poly )
          }

          Gibberish.blockCallbacks.push( envCheck )
        },

        chord( frequencies ) {
          frequencies.forEach( (v) => synth.note(v) )
          this.triggerChord = frequencies
        },

        free() {
          for( let child of voices ) child.free()
        }
      })
      
      let _propertyList 
      if( properties.isStereo === false ) {
        _propertyList = propertyList.slice( 0 )
        let idx =  _propertyList.indexOf( 'pan' )
        if( idx  > -1 ) _propertyList.splice( idx, 1 )
      }

      TemplateFactory.setupProperties( synth, ugen, properties.isStereo ? propertyList : _propertyList )

      return synth
    }

    return Template
  }

  TemplateFactory.setupProperties = ( synth, ugen, props ) => {
    for( let property of props ) {
      Object.defineProperty( synth, property, {
        get() {
          return synth.properties[ property ] || ugen.defaults[ property ]
        },
        set( v ) {
          synth.properties[ property ] = v
          for( let child of synth.inputs ) {
            child[ property ] = v
          }
        }
      })
    }
  }

  return TemplateFactory

}
